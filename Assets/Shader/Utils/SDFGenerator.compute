#include "./HexLibrary.hlsl"

#pragma kernel InitJFA
#pragma kernel JFAIter
#pragma kernel GenSDF

#define EDGE_PIXEL 0
#define INNER_PIXEL 1
#define OUTTER_PIXEL 2
#define UNVALID_PIXEL 3
float4 UNVALID_PIXEL_VALUE = float4(-1, -1, -1, -1);
float2 NO_KETPOINT_VALUE = float2(-1, -1);

int _TerrainWidth;
int _TerrainHeight;
int _ClusterSize;

int _HexGridSize;
int _StartLongitude;
int _StartLatitude;

int _HexmapWidth;   // 与 GridTerrainTexture 和 CountryTexture 大小一致
int _HexmapHeight;

int _OutterTerColorCount;
StructuredBuffer<float4> OutterTerrainColor; // 即 被认为是无法划入 country 的地形颜色列表
// float4 _MountainColor;
// float4 _ShallowSeaColor;
// float4 _DeepSeaColor;

Texture2D<float4> GridTerrainTexture;           // 用于存储 GridTerrain Data
Texture2D<float4> CountryTexture;           // 用于存储 Country Data

RWStructuredBuffer<float4> PixelDataBuffer;         // 用于存储 JFA 计算所需的数据
RWStructuredBuffer<float4> PixelJFAInfoBuffer; 
// TODO : Result datas

static const int neighborOffsetsLength = 8;
static const int2 neighborOffsets[8] = {
    int2(-1, -1), int2(0, -1), int2(1, -1),
    int2(-1,  0),              int2(1,  0),
    int2(-1,  1), int2(0,  1), int2(1,  1)
};

inline int GetPixelIndex(int x, int y)
{
    return x * _ClusterSize + y;
}

inline bool CheckWorldPosValid(int x, int y)
{
    return (x >= 0 && x < _TerrainWidth * _ClusterSize) && (y >= 0 && y < _TerrainHeight * _ClusterSize);
}

inline bool CheckPixelValid(int x, int y)
{
    return (x >= 0 && x < _HexmapWidth) && (y >= 0 && y < _HexmapHeight);
}

// // Copy from HexLibrary.hlsl
// inline float3 WorldToCube(float3 worldPos, float _HexGridSize){
//     float q = (sqrt(3)/3 * worldPos.x  -  1./3 * worldPos.z) / _HexGridSize;
//     float r = 2./3 * worldPos.z / _HexGridSize;
//     float s = - q - r;

//     float fix_q = round(q);
//     float fix_r = round(r);
//     float fix_s = round(s);

//     float q_diff = abs(fix_q - q);
//     float r_diff = abs(fix_r - r);
//     float s_diff = abs(fix_s - s);

//     float final_q = fix_q, final_r = fix_r, final_s = fix_s;
//     if(q_diff > r_diff && q_diff > s_diff){
//         final_q = - fix_r - fix_s;
//     }else if(r_diff > s_diff){
//         final_r = - fix_q - fix_s;
//     }else{
//         final_s = - fix_q - fix_r;
//     }
//     return float3(final_q, final_r, final_s);
// }
// inline float3 CubeCoordToOffset(float3 cubePos){
//     float col = cubePos.x + (cubePos.y - ((int)cubePos.y&1)) / 2;
//     float row = cubePos.y;
//     return float3(col, row, -col-row);
// }
// inline int2 WorldPosToOffsetHex(int x, int y){
//     float3 cubePos = WorldToCube(float3(x, 0, y), _HexGridSize);
//     return CubeCoordToOffset(cubePos);
// }

inline int GetPixelType(int2 worldPos, int2 offsetHex)
{
    if (!CheckWorldPosValid(worldPos.x, worldPos.y)){
        return UNVALID_PIXEL;
    }
    
    if(!CheckPixelValid(offsetHex.x, offsetHex.y)){
        return UNVALID_PIXEL;
    }

    // 检查 gridterrain 是否是不能作为 country 的terrain, 若是 则为 outter pixel
    float4 gridTerrainColor = GridTerrainTexture[offsetHex];
    for (int i = 0; i < _OutterTerColorCount; i++){
        if (all(gridTerrainColor == OutterTerrainColor[i])){
            return OUTTER_PIXEL;
        }
    }

    float4 countryColor = CountryTexture[offsetHex];
    for (int j = 0; j < neighborOffsetsLength; j++) {
        int2 neighborWorld = worldPos + neighborOffsets[j];
        if (!CheckWorldPosValid(neighborWorld.x, neighborWorld.y)){
            continue;
        }

        // 如果 neighborPos 属于不同的区域，则说明 offsetHex 是边缘点
        float3 neighborWorld_f3 = float3(neighborWorld.x, 0, neighborWorld.y);
        int2 neighborPos = WorldToOffset(neighborWorld_f3, _HexGridSize);
        if (!CheckPixelValid(neighborPos.x, neighborPos.y)){
            continue;
        }
        float4 neighborCountry = CountryTexture[neighborPos];
        if(all(countryColor != neighborCountry)){
            return EDGE_PIXEL;
        }
    }
    return INNER_PIXEL;
}

[numthreads(16,16,1)]
void InitJFA (uint3 id : SV_DispatchThreadID)
{
    int x = (int)id.x;
    int y = (int)id.y;
    int2 baseOffset = int2(_StartLongitude * _ClusterSize, _StartLatitude * _ClusterSize);
    int2 worldPos = int2(x, y) + baseOffset;
    float3 worldPos_f3 = float3(worldPos.x, 0, worldPos.y);
    int2 offsetHex = WorldToOffset(worldPos_f3, _HexGridSize);
    int pixelType = GetPixelType(worldPos, offsetHex);

    // if point is edge point   : (x, y, x, y)
    // if point is inner point  : (x, y, -1, -1)
    // if point is outter point : (-1, -1, x, y)    , sea, mountain, lake is outter point
    // JFA data will be used in JFAIter
    int pixelCoord = GetPixelIndex(x, y);
    if(pixelType == EDGE_PIXEL){
        PixelDataBuffer[pixelCoord] = float4(x, y, x, y);
    }else if(pixelType == INNER_PIXEL){
        PixelDataBuffer[pixelCoord] = float4(x, y, -1, -1);
    }else if(pixelType == OUTTER_PIXEL){
        PixelDataBuffer[pixelCoord] = float4(-1, -1, x, y);
    }else{
        PixelDataBuffer[pixelCoord] = UNVALID_PIXEL_VALUE;
    }
}

int _CurStep;

struct PixelType_JFA {
    int pixelType;
    int2 keyPointVal;
};

inline PixelType_JFA GetPixelType_JFA(int2 worldPos)
{
    int index = GetPixelIndex(worldPos.x, worldPos.y);
    float4 pixelData = PixelDataBuffer[index];
    int2 prefix = int2((int)pixelData.x, (int)pixelData.y);
    int2 suffix = int2((int)pixelData.z, (int)pixelData.w);

    PixelType_JFA res;
    if (all(prefix == suffix))
    {
        res.keyPointVal = prefix;
        res.pixelType = EDGE_PIXEL;
    }
    else if (all(prefix == worldPos))
    {
        res.keyPointVal = suffix;
        res.pixelType = INNER_PIXEL;
    }
    else if (all(suffix == worldPos))
    {
        res.keyPointVal = prefix;
        res.pixelType = OUTTER_PIXEL;
    }
    else
    {
        // Wrong ! 
        res.pixelType = UNVALID_PIXEL;
    }
    return res;
}

void UpdateKeyPoint(int pixelType, int2 idx, int2 newKeyPointVal)
{
    int index = idx.x * _ClusterSize + idx.y;
    // if point is edge point   : (x, y, x, y)
    // if point is inner point  : (x, y, -1, -1)
    // if point is outter point : (-1, -1, x, y)
    if (pixelType == INNER_PIXEL)
    {
        PixelJFAInfoBuffer[index] = float4(idx.x, idx.y, newKeyPointVal.x, newKeyPointVal.y);
    }
    else if(pixelType == OUTTER_PIXEL){
        PixelJFAInfoBuffer[index] = float4(newKeyPointVal.x, newKeyPointVal.y, idx.x, idx.y);
    }
}

void SampleKeyPoint(int2 worldPos, int2 sampleTarget)
{
    PixelType_JFA curPixelRes = GetPixelType_JFA(worldPos);
    PixelType_JFA samplePixelRes = GetPixelType_JFA(sampleTarget);
    int curPixelType = curPixelRes.pixelType;
    int samplePixelType = samplePixelRes.pixelType;
    int2 curKeyPoint = curPixelRes.keyPointVal;
    int2 sampleKeyPoint = samplePixelRes.keyPointVal;

    float2 worldPos_f2 = float2(worldPos);
    float2 sampleKeyPoint_f2 = float2(sampleKeyPoint);
    float2 curKeyPoint_f2 = float2(curKeyPoint);

    if (all(curKeyPoint == NO_KETPOINT_VALUE)){
        UpdateKeyPoint(curPixelType, worldPos, sampleKeyPoint);
    }else if (all(sampleKeyPoint == NO_KETPOINT_VALUE)){
        // Nothing happen
        // TODO : 下面的判断可能有问题
    }else if (length(worldPos_f2 - sampleKeyPoint_f2) < length(worldPos_f2 - curKeyPoint_f2))
    {
        UpdateKeyPoint(curPixelType, worldPos, sampleKeyPoint);
    }
}

// TODO : 两个待解决的问题 ： 
// 1. step 是不是只能在 C# 层次设置，这样会不会导致性能问题？
// 2. 在计算时，是否应该额外地计算周围 3 x 3 的区域 （仅对它们执行 InitJFAInfo），然后对目标区域执行 JFAIter ？
[numthreads(16,16,1)]
void JFAIter (uint3 id : SV_DispatchThreadID)
{
    int x = (int)id.x;
    int y = (int)id.y;
    int2 pixelPos = int2(x, y);
    int2 baseOffset = int2(_StartLongitude * _ClusterSize, _StartLatitude * _ClusterSize);
    int2 worldPos = pixelPos + baseOffset;

    for (int i = 0; i < neighborOffsetsLength; i++) {
        int2 sampleTarget = pixelPos + neighborOffsets[i] * _CurStep;
        if (!CheckWorldPosValid(sampleTarget.x, sampleTarget.y)){
            continue;
        }
        SampleKeyPoint(worldPos, sampleTarget);
    }
}

[numthreads(16,16,1)]
void GenSDF (uint3 id : SV_DispatchThreadID)
{
    // TODO : 完成这里
}
